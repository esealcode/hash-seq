It could've been owned by Allan, but it won't so I make it orphan.

Hashes are interesting by nature, because we are humans and humans amount to nothing to the universe, it allows to compress any data into a fixed length binary number. This fascinating property is leveraged a lot in computer sciences. It does allow people to verify integrity, to sign binary data, heck it's even the basic foundation of what makes Bitcoin possible and most blockchains heavily rely of those properties too. However I do think there are more possibilities. One thing I wanted to initially explore is that hashes are just big random numbers, and big random numbers are great for seeding PRNGs and all. But I do believe that there is a lack of consideration for what the actual plaintext is and means, we're missing out on that. 

Before going further, we need to remember the first sentence of this post that refersto the horrendously high amount of possible output of a robust hash function. That's why we consider safe to assume that the known sha256 hash of a file can be used to verify the integrity of one we download. In short, we create a bond. A bond between this very large number although still limited and the file data that represent one possibility amongst virtually an infinite amount of them, counter intuitive. But finding another file with the same hash is almost impossible. Don't get me wrong, it is assumed to be impossible for us, fellow humans, but instead it is necessarily possible in mathematics because of what's called the pigeonhole principle. It states that if there are less holes that pigeons then at least one hole must necessarily contains multiple pigeons. That's what we call a collision with hashes, theoretically a file always hashes to another file hash but that's just theory though, not in practice. In practice even by uniting all our computing power, trying to find a collision would takes millions of years if not more, and this is exactly what we exploit here. All of the previous assumes that the hash is sound, and as of writing sha256 is considered to be robust.

With all this knowledge in mind, we can get back to the meaning of our little plaintexts. We can now essentially safely assume that there is a 1:1 mapping between a plaintext and its hash meaning that they're equivalent. This assumption opens very powerful possibilities when we combine it with plaintexts being actual self-referencing contracts. By self-referencing, we mean that the contract is aware of the context it lives in, the contract for the text you're reading is no different. It makes implicit reference to what I'm writing. A contract can be way more complex though, you can set any rule as long as they are reasonable enough.

We enter the realm of philosophy now, because some might still rightly ask why the contract would apply to this text? Well. There is one thing you still don't know yet about what you're reading. Each sentence is deliberatly derived from the contract itself. Remember? Contract, hash, same thing really to us. The contract is hashed into a sha256 output which we then use to create a PRNG. This PRNG is simple and not perfect compared to traditional PRNGs but is good enough. In short, the idea is to: compute (hash mod n) where n is the upper bound and zero is the lower bound for our own random function. Then we hash the current hash again to get another state that'll generate other numbers. Even if hashes aren't meant to do this, they are close enough to other proper PRNGs here. Now, you might have guessed it already but we do generate something random for each sentence you've read so far, that is their word count. Each sentence word count (defined are space separated text) are deliberate, and yes the one you're reading makes no exception to this seemingly weird shitty rule.

Now the thing is, you might still ask why, why does it matter? Well it does because this sequence of sentence word count is uniquely derived from our hash. So, our contract is bound to our hash but with a twist. Our hash is now also bound to this unique sentence word count sequence which makes this sequence by definition equivalent to our contract because chances are statistically low enough. At this point, we have 37 sentences, each containing a deliberate amount of words I wrote. Each sentence can have between 6 and 32 words in it. It amounts to 26 possible word count per sentence, meaning that the probability so far is 1/(26^39) which is more than 2^128 possible paths. Note 2^128 is considered safe enough already such that we can't reliably bruteforce our way into finding another contract that would yield the same exact sequence. Is it making the writing experience worse? Probably slightly, but not that much so far, probably a bit more challenging. I do think it's fun though. However it's probably the easiest example of leveraring hashes to assign contract to a data. The data is not limited by any means, some type of data can however be more challenging to work with though. It can work for digital artworks, physical artworks, photography and probably most other things we can think about. We do have to tweak the way we generate them though, digital artworks would require generating random traits to add for instance. So yeah, as the contract for this text says: It could've been owned by Allan, but it won't so I make it orphan; Though it's probably not the best.